import { jsx as z, jsxs as Nt, Fragment as lo } from "react/jsx-runtime";
import H, { createElement as _t } from "react";
import co from "react-dom";
const we = 0, zt = 1, qt = 2, kn = 4;
function cn(t) {
  return () => t;
}
function uo(t) {
  t();
}
function ne(t, e) {
  return (n) => t(e(n));
}
function un(t, e) {
  return () => t(e);
}
function ao(t, e) {
  return (n) => t(e, n);
}
function Me(t) {
  return t !== void 0;
}
function fo(...t) {
  return () => {
    t.map(uo);
  };
}
function Yt() {
}
function ve(t, e) {
  return e(t), t;
}
function mo(t, e) {
  return e(t);
}
function X(...t) {
  return t;
}
function K(t, e) {
  return t(zt, e);
}
function G(t, e) {
  t(we, e);
}
function We(t) {
  t(qt);
}
function st(t) {
  return t(kn);
}
function O(t, e) {
  return K(t, ao(e, we));
}
function bt(t, e) {
  const n = t(zt, (o) => {
    n(), e(o);
  });
  return n;
}
function an(t) {
  let e, n;
  return (o) => (r) => {
    e = r, n && clearTimeout(n), n = setTimeout(() => {
      o(e);
    }, t);
  };
}
function Fn(t, e) {
  return t === e;
}
function Z(t = Fn) {
  let e;
  return (n) => (o) => {
    t(e, o) || (e = o, n(o));
  };
}
function P(t) {
  return (e) => (n) => {
    t(n) && e(n);
  };
}
function E(t) {
  return (e) => ne(e, t);
}
function yt(t) {
  return (e) => () => {
    e(t);
  };
}
function x(t, ...e) {
  const n = po(...e);
  return (o, r) => {
    switch (o) {
      case qt:
        We(t);
        return;
      case zt:
        return K(t, n(r));
    }
  };
}
function Rt(t, e) {
  return (n) => (o) => {
    n(e = t(e, o));
  };
}
function jt(t) {
  return (e) => (n) => {
    t > 0 ? t-- : e(n);
  };
}
function Lt(t) {
  let e = null, n;
  return (o) => (r) => {
    e = r, !n && (n = setTimeout(() => {
      n = void 0, o(e);
    }, t));
  };
}
function _(...t) {
  const e = new Array(t.length);
  let n = 0, o = null;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      const a = n;
      n = n | l, e[i] = c, a !== r && n === r && o && (o(), o = null);
    });
  }), (s) => (i) => {
    const l = () => {
      s([i].concat(e));
    };
    n === r ? l() : o = l;
  };
}
function po(...t) {
  return (e) => t.reduceRight(mo, e);
}
function ho(t) {
  let e, n;
  const o = () => e == null ? void 0 : e();
  return function(r, s) {
    switch (r) {
      case zt:
        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);
      case qt:
        o(), n = null;
        return;
    }
  };
}
function C(t) {
  let e = t;
  const n = $();
  return (o, r) => {
    switch (o) {
      case we:
        e = r;
        break;
      case zt: {
        r(e);
        break;
      }
      case kn:
        return e;
    }
    return n(o, r);
  };
}
function ct(t, e) {
  return ve(C(e), (n) => O(t, n));
}
function $() {
  const t = [];
  return (e, n) => {
    switch (e) {
      case we:
        t.slice().forEach((o) => {
          o(n);
        });
        return;
      case qt:
        t.splice(0, t.length);
        return;
      case zt:
        return t.push(n), () => {
          const o = t.indexOf(n);
          o > -1 && t.splice(o, 1);
        };
    }
  };
}
function ht(t) {
  return ve($(), (e) => O(t, e));
}
function U(t, e = [], { singleton: n } = { singleton: !0 }) {
  return {
    constructor: t,
    dependencies: e,
    id: go(),
    singleton: n
  };
}
const go = () => Symbol();
function Io(t) {
  const e = /* @__PURE__ */ new Map(), n = ({ constructor: o, dependencies: r, id: s, singleton: i }) => {
    if (i && e.has(s))
      return e.get(s);
    const l = o(r.map((c) => n(c)));
    return i && e.set(s, l), l;
  };
  return n(t);
}
function rt(...t) {
  const e = $(), n = new Array(t.length);
  let o = 0;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      n[i] = c, o = o | l, o === r && G(e, n);
    });
  }), function(s, i) {
    switch (s) {
      case qt: {
        We(e);
        return;
      }
      case zt:
        return o === r && i(n), K(e, i);
    }
  };
}
function A(t, e = Fn) {
  return x(t, Z(e));
}
function dn(...t) {
  return function(e, n) {
    switch (e) {
      case qt:
        return;
      case zt:
        return fo(...t.map((o) => K(o, n)));
    }
  };
}
var mt = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(mt || {});
const So = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
}, xo = () => typeof globalThis > "u" ? window : globalThis, Vt = U(
  () => {
    const t = C(
      3
      /* ERROR */
    );
    return {
      log: C((n, o, r = 1) => {
        var i;
        const s = (i = xo().VIRTUOSO_LOG_LEVEL) != null ? i : st(t);
        r >= s && console[So[r]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n,
          o
        );
      }),
      logLevel: t
    };
  },
  [],
  { singleton: !0 }
);
function Ht(t, e, n) {
  return Ge(t, e, n).callbackRef;
}
function Ge(t, e, n) {
  const o = H.useRef(null);
  let r = (i) => {
  };
  const s = H.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i) => {
    const l = () => {
      const c = i[0].target;
      c.offsetParent !== null && t(c);
    };
    n ? l() : requestAnimationFrame(l);
  }) : null, [t, n]);
  return r = (i) => {
    i && e ? (s == null || s.observe(i), o.current = i) : (o.current && (s == null || s.unobserve(o.current)), o.current = null);
  }, { callbackRef: r, ref: o };
}
function On(t, e, n, o, r, s, i, l, c) {
  const a = H.useCallback(
    (p) => {
      const S = To(p.children, e, l ? "offsetWidth" : "offsetHeight", r);
      let g = p.parentElement;
      for (; !g.dataset.virtuosoScroller; )
        g = g.parentElement;
      const h = g.lastElementChild.dataset.viewportType === "window";
      let w;
      h && (w = g.ownerDocument.defaultView);
      const v = i ? l ? i.scrollLeft : i.scrollTop : h ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? g.scrollLeft : g.scrollTop, m = i ? l ? i.scrollWidth : i.scrollHeight : h ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? g.scrollWidth : g.scrollHeight, d = i ? l ? i.offsetWidth : i.offsetHeight : h ? l ? w.innerWidth : w.innerHeight : l ? g.offsetWidth : g.offsetHeight;
      o({
        scrollHeight: m,
        scrollTop: Math.max(v, 0),
        viewportHeight: d
      }), s == null || s(
        l ? fn("column-gap", getComputedStyle(p).columnGap, r) : fn("row-gap", getComputedStyle(p).rowGap, r)
      ), S !== null && t(S);
    },
    [t, e, r, s, i, o, l]
  );
  return Ge(a, n, c);
}
function To(t, e, n, o) {
  const r = t.length;
  if (r === 0)
    return null;
  const s = [];
  for (let i = 0; i < r; i++) {
    const l = t.item(i);
    if (l.dataset.index === void 0)
      continue;
    const c = parseInt(l.dataset.index), a = parseFloat(l.dataset.knownSize), p = e(l, n);
    if (p === 0 && o("Zero-sized element, this should not happen", { child: l }, mt.ERROR), p === a)
      continue;
    const S = s[s.length - 1];
    s.length === 0 || S.size !== p || S.endIndex !== c - 1 ? s.push({ endIndex: c, size: p, startIndex: c }) : s[s.length - 1].endIndex++;
  }
  return s;
}
function fn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
function _e(t, e, n) {
  const o = H.useRef(null), r = H.useCallback(
    (c) => {
      if (!(c != null && c.offsetParent))
        return;
      const a = c.getBoundingClientRect(), p = a.width;
      let S, g;
      if (e) {
        const h = e.getBoundingClientRect(), w = a.top - h.top;
        g = h.height - Math.max(0, w), S = w + e.scrollTop;
      } else {
        const h = i.current.ownerDocument.defaultView;
        g = h.innerHeight - Math.max(0, a.top), S = a.top + h.scrollY;
      }
      o.current = {
        offsetTop: S,
        visibleHeight: g,
        visibleWidth: p
      }, t(o.current);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t, e]
  ), { callbackRef: s, ref: i } = Ge(r, !0, n), l = H.useCallback(() => {
    r(i.current);
  }, [r, i]);
  return H.useEffect(() => {
    var c;
    if (e) {
      e.addEventListener("scroll", l);
      const a = new ResizeObserver(() => {
        requestAnimationFrame(l);
      });
      return a.observe(e), () => {
        e.removeEventListener("scroll", l), a.unobserve(e);
      };
    } else {
      const a = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
      return a == null || a.addEventListener("scroll", l), a == null || a.addEventListener("resize", l), () => {
        a == null || a.removeEventListener("scroll", l), a == null || a.removeEventListener("resize", l);
      };
    }
  }, [l, e, i]), s;
}
const at = U(
  () => {
    const t = $(), e = $(), n = C(0), o = $(), r = C(0), s = $(), i = $(), l = C(0), c = C(0), a = C(0), p = C(0), S = $(), g = $(), h = C(!1), w = C(!1), v = C(!1);
    return O(
      x(
        t,
        E(({ scrollTop: m }) => m)
      ),
      e
    ), O(
      x(
        t,
        E(({ scrollHeight: m }) => m)
      ),
      i
    ), O(e, r), {
      deviation: n,
      fixedFooterHeight: a,
      fixedHeaderHeight: c,
      footerHeight: p,
      headerHeight: l,
      horizontalDirection: w,
      scrollBy: g,
      // input
      scrollContainerState: t,
      scrollHeight: i,
      scrollingInProgress: h,
      // signals
      scrollTo: S,
      scrollTop: e,
      skipAnimationFrameInResizeObserver: v,
      smoothScrollTargetReached: o,
      // state
      statefulScrollTop: r,
      viewportHeight: s
    };
  },
  [],
  { singleton: !0 }
), oe = { lvl: 0 };
function Ln(t, e) {
  const n = t.length;
  if (n === 0)
    return [];
  let { index: o, value: r } = e(t[0]);
  const s = [];
  for (let i = 1; i < n; i++) {
    const { index: l, value: c } = e(t[i]);
    s.push({ end: l - 1, start: o, value: r }), o = l, r = c;
  }
  return s.push({ end: 1 / 0, start: o, value: r }), s;
}
function j(t) {
  return t === oe;
}
function re(t, e) {
  if (!j(t))
    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);
}
function Ct(t, e, n = "k") {
  if (j(t))
    return [-1 / 0, void 0];
  if (Number(t[n]) === e)
    return [t.k, t.v];
  if (Number(t[n]) < e) {
    const o = Ct(t.r, e, n);
    return o[0] === -1 / 0 ? [t.k, t.v] : o;
  }
  return Ct(t.l, e, n);
}
function pt(t, e, n) {
  return j(t) ? Pn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? mn(ot(t, { l: pt(t.l, e, n) })) : mn(ot(t, { r: pt(t.r, e, n) }));
}
function Kt() {
  return oe;
}
function ye(t, e, n) {
  if (j(t))
    return [];
  const o = Ct(t, e)[0];
  return Co(ze(t, o, n));
}
function Le(t, e) {
  if (j(t)) return oe;
  const { k: n, l: o, r } = t;
  if (e === n) {
    if (j(o))
      return r;
    if (j(r))
      return o;
    {
      const [s, i] = Vn(o);
      return ge(ot(t, { k: s, l: zn(o), v: i }));
    }
  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));
}
function Gt(t) {
  return j(t) ? [] : [...Gt(t.l), { k: t.k, v: t.v }, ...Gt(t.r)];
}
function ze(t, e, n) {
  if (j(t))
    return [];
  const { k: o, l: r, r: s, v: i } = t;
  let l = [];
  return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;
}
function ge(t) {
  const { l: e, lvl: n, r: o } = t;
  if (o.lvl >= n - 1 && e.lvl >= n - 1)
    return t;
  if (n > o.lvl + 1) {
    if (Ee(e))
      return An(ot(t, { lvl: n - 1 }));
    if (!j(e) && !j(e.r))
      return ot(e.r, {
        l: ot(e, { r: e.r.l }),
        lvl: n,
        r: ot(t, {
          l: e.r.r,
          lvl: n - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t))
      return Ve(ot(t, { lvl: n - 1 }));
    if (!j(o) && !j(o.l)) {
      const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;
      return ot(r, {
        l: ot(t, {
          lvl: n - 1,
          r: r.l
        }),
        lvl: r.lvl + 1,
        r: Ve(ot(o, { l: r.r, lvl: s }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function ot(t, e) {
  return Pn(
    e.k !== void 0 ? e.k : t.k,
    e.v !== void 0 ? e.v : t.v,
    e.lvl !== void 0 ? e.lvl : t.lvl,
    e.l !== void 0 ? e.l : t.l,
    e.r !== void 0 ? e.r : t.r
  );
}
function zn(t) {
  return j(t.r) ? t.l : ge(ot(t, { r: zn(t.r) }));
}
function Ee(t) {
  return j(t) || t.lvl > t.r.lvl;
}
function Vn(t) {
  return j(t.r) ? [t.k, t.v] : Vn(t.r);
}
function Pn(t, e, n, o = oe, r = oe) {
  return { k: t, l: o, lvl: n, r, v: e };
}
function mn(t) {
  return Ve(An(t));
}
function An(t) {
  const { l: e } = t;
  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;
}
function Ve(t) {
  const { lvl: e, r: n } = t;
  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;
}
function Co(t) {
  return Ln(t, ({ k: e, v: n }) => ({ index: e, value: n }));
}
function Mn(t, e) {
  return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);
}
function se(t, e) {
  return !!(t && t[0] === e[0] && t[1] === e[1]);
}
const Ne = U(
  () => ({ recalcInProgress: C(!1) }),
  [],
  { singleton: !0 }
);
function Wn(t, e, n) {
  return t[Se(t, e, n)];
}
function Se(t, e, n, o = 0) {
  let r = t.length - 1;
  for (; o <= r; ) {
    const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);
    if (l === 0)
      return s;
    if (l === -1) {
      if (r - o < 2)
        return s - 1;
      r = s - 1;
    } else {
      if (r === o)
        return s;
      o = s + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${t.join(",")}, searched for ${e}`);
}
function wo(t, e, n, o) {
  const r = Se(t, e, o), s = Se(t, n, o, r);
  return t.slice(r, s + 1);
}
function wt(t, e) {
  return Math.round(t.getBoundingClientRect()[e]);
}
function Re(t) {
  return !j(t.groupOffsetTree);
}
function De({ index: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function vo() {
  return {
    groupIndices: [],
    groupOffsetTree: Kt(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: Kt()
  };
}
function yo(t, e) {
  let n = j(t) ? 0 : 1 / 0;
  for (const o of e) {
    const { endIndex: r, size: s, startIndex: i } = o;
    if (n = Math.min(n, i), j(t)) {
      t = pt(t, 0, s);
      continue;
    }
    const l = ye(t, i - 1, r + 1);
    if (l.some(Fo(o)))
      continue;
    let c = !1, a = !1;
    for (const { end: p, start: S, value: g } of l)
      c ? (r >= S || s === g) && (t = Le(t, S)) : (a = g !== s, c = !0), p > r && r >= S && g !== s && (t = pt(t, r + 1, g));
    a && (t = pt(t, i, s));
  }
  return [t, n];
}
function Ro(t) {
  return typeof t.groupIndex < "u";
}
function bo({ offset: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function ie(t, e, n) {
  if (e.length === 0)
    return 0;
  const { index: o, offset: r, size: s } = Wn(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;
  return l > 0 ? l + n : l;
}
function Gn(t, e) {
  if (!Re(e))
    return t;
  let n = 0;
  for (; e.groupIndices[n] <= t + n; )
    n++;
  return t + n;
}
function _n(t, e, n) {
  if (Ro(t))
    return e.groupIndices[t.groupIndex] + 1;
  {
    const o = t.index === "LAST" ? n : t.index;
    let r = Gn(o, e);
    return r = Math.max(0, r, Math.min(n, r)), r;
  }
}
function Ho(t, e, n, o = 0) {
  return o > 0 && (e = Math.max(e, Wn(t, o, De).offset)), Ln(wo(t, e, n, bo), ko);
}
function Eo(t, [e, n, o, r]) {
  e.length > 0 && o("received item sizes", e, mt.DEBUG);
  const s = t.sizeTree;
  let i = s, l = 0;
  if (n.length > 0 && j(s) && e.length === 2) {
    const g = e[0].size, h = e[1].size;
    i = n.reduce((w, v) => pt(pt(w, v, g), v + 1, h), i);
  } else
    [i, l] = yo(i, e);
  if (i === s)
    return t;
  const { lastIndex: c, lastOffset: a, lastSize: p, offsetTree: S } = Pe(t.offsetTree, l, i, r);
  return {
    groupIndices: n,
    groupOffsetTree: n.reduce((g, h) => pt(g, h, ie(h, S, r)), Kt()),
    lastIndex: c,
    lastOffset: a,
    lastSize: p,
    offsetTree: S,
    sizeTree: i
  };
}
function Bo(t) {
  return Gt(t).map(({ k: e, v: n }, o, r) => {
    const s = r[o + 1];
    return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };
  });
}
function pn(t, e) {
  let n = 0, o = 0;
  for (; n < t; )
    n += e[o + 1] - e[o] - 1, o++;
  return o - (n === t ? 0 : 1);
}
function Pe(t, e, n, o) {
  let r = t, s = 0, i = 0, l = 0, c = 0;
  if (e !== 0) {
    c = Se(r, e - 1, De), l = r[c].offset;
    const p = Ct(n, e - 1);
    s = p[0], i = p[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
  } else
    r = [];
  for (const { start: a, value: p } of ye(n, e, 1 / 0)) {
    const S = a - s, g = S * i + l + S * o;
    r.push({
      index: a,
      offset: g,
      size: p
    }), s = a, l = g, i = p;
  }
  return {
    lastIndex: s,
    lastOffset: l,
    lastSize: i,
    offsetTree: r
  };
}
function ko(t) {
  return { index: t.index, value: t };
}
function Fo(t) {
  const { endIndex: e, size: n, startIndex: o } = t;
  return (r) => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;
}
const Oo = {
  offsetHeight: "height",
  offsetWidth: "width"
}, Et = U(
  ([{ log: t }, { recalcInProgress: e }]) => {
    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = C(0), c = C([]), a = C(void 0), p = C(void 0), S = C((I, f) => wt(I, Oo[f])), g = C(void 0), h = C(0), w = vo(), v = ct(
      x(n, _(c, t, h), Rt(Eo, w), Z()),
      w
    ), m = ct(
      x(
        c,
        Z(),
        Rt((I, f) => ({ current: f, prev: I.current }), {
          current: [],
          prev: []
        }),
        E(({ prev: I }) => I)
      ),
      []
    );
    O(
      x(
        c,
        P((I) => I.length > 0),
        _(v, h),
        E(([I, f, b]) => {
          const k = I.reduce((F, L, V) => pt(F, L, ie(L, f.offsetTree, b) || V), Kt());
          return {
            ...f,
            groupIndices: I,
            groupOffsetTree: k
          };
        })
      ),
      v
    ), O(
      x(
        o,
        _(v),
        P(([I, { lastIndex: f }]) => I < f),
        E(([I, { lastIndex: f, lastSize: b }]) => [
          {
            endIndex: f,
            size: b,
            startIndex: I
          }
        ])
      ),
      n
    ), O(a, p);
    const d = ct(
      x(
        a,
        E((I) => I === void 0)
      ),
      !0
    );
    O(
      x(
        p,
        P((I) => I !== void 0 && j(st(v).sizeTree)),
        E((I) => [{ endIndex: 0, size: I, startIndex: 0 }])
      ),
      n
    );
    const u = ht(
      x(
        n,
        _(v),
        Rt(
          ({ sizes: I }, [f, b]) => ({
            changed: b !== I,
            sizes: b
          }),
          { changed: !1, sizes: w }
        ),
        E((I) => I.changed)
      )
    );
    K(
      x(
        l,
        Rt(
          (I, f) => ({ diff: I.prev - f, prev: f }),
          { diff: 0, prev: 0 }
        ),
        E((I) => I.diff)
      ),
      (I) => {
        const { groupIndices: f } = st(v);
        if (I > 0)
          G(e, !0), G(s, I + pn(I, f));
        else if (I < 0) {
          const b = st(m);
          b.length > 0 && (I -= pn(-I, b)), G(i, I);
        }
      }
    ), K(x(l, _(t)), ([I, f]) => {
      I < 0 && f(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l },
        mt.ERROR
      );
    });
    const T = ht(s);
    O(
      x(
        s,
        _(v),
        E(([I, f]) => {
          const b = f.groupIndices.length > 0, k = [], F = f.lastSize;
          if (b) {
            const L = re(f.sizeTree, 0);
            let V = 0, D = 0;
            for (; V < I; ) {
              const B = f.groupIndices[D], Y = f.groupIndices.length === D + 1 ? 1 / 0 : f.groupIndices[D + 1] - B - 1;
              k.push({
                endIndex: B,
                size: L,
                startIndex: B
              }), k.push({
                endIndex: B + 1 + Y - 1,
                size: F,
                startIndex: B + 1
              }), D++, V += Y + 1;
            }
            const J = Gt(f.sizeTree);
            return V !== I && J.shift(), J.reduce(
              (B, { k: Y, v: it }) => {
                let dt = B.ranges;
                return B.prevSize !== 0 && (dt = [
                  ...B.ranges,
                  {
                    endIndex: Y + I - 1,
                    size: B.prevSize,
                    startIndex: B.prevIndex
                  }
                ]), {
                  prevIndex: Y + I,
                  prevSize: it,
                  ranges: dt
                };
              },
              {
                prevIndex: I,
                prevSize: 0,
                ranges: k
              }
            ).ranges;
          }
          return Gt(f.sizeTree).reduce(
            (L, { k: V, v: D }) => ({
              prevIndex: V + I,
              prevSize: D,
              ranges: [...L.ranges, { endIndex: V + I - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: F,
              ranges: []
            }
          ).ranges;
        })
      ),
      n
    );
    const R = ht(
      x(
        i,
        _(v, h),
        E(([I, { offsetTree: f }, b]) => {
          const k = -I;
          return ie(k, f, b);
        })
      )
    );
    return O(
      x(
        i,
        _(v, h),
        E(([I, f, b]) => {
          if (f.groupIndices.length > 0) {
            if (j(f.sizeTree))
              return f;
            let F = Kt();
            const L = st(m);
            let V = 0, D = 0, J = 0;
            for (; V < -I; ) {
              J = L[D];
              const B = L[D + 1] - J - 1;
              D++, V += B + 1;
            }
            if (F = Gt(f.sizeTree).reduce((B, { k: Y, v: it }) => pt(B, Math.max(0, Y + I), it), F), V !== -I) {
              const B = re(f.sizeTree, J);
              F = pt(F, 0, B);
              const Y = Ct(f.sizeTree, -I + 1)[1];
              F = pt(F, 1, Y);
            }
            return {
              ...f,
              sizeTree: F,
              ...Pe(f.offsetTree, 0, F, b)
            };
          } else {
            const F = Gt(f.sizeTree).reduce((L, { k: V, v: D }) => pt(L, Math.max(0, V + I), D), Kt());
            return {
              ...f,
              sizeTree: F,
              ...Pe(f.offsetTree, 0, F, b)
            };
          }
        })
      ),
      v
    ), {
      beforeUnshiftWith: T,
      // input
      data: g,
      defaultItemSize: p,
      firstItemIndex: l,
      fixedItemSize: a,
      gap: h,
      groupIndices: c,
      itemSize: S,
      listRefresh: u,
      shiftWith: i,
      shiftWithOffset: R,
      sizeRanges: n,
      // output
      sizes: v,
      statefulTotalCount: r,
      totalCount: o,
      trackItemSizes: d,
      unshiftWith: s
    };
  },
  X(Vt, Ne),
  { singleton: !0 }
);
function Lo(t) {
  return t.reduce(
    (e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
const Nn = U(
  ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {
    const s = $(), i = $(), l = ht(x(s, E(Lo)));
    return O(
      x(
        l,
        E((c) => c.totalCount)
      ),
      n
    ), O(
      x(
        l,
        E((c) => c.groupIndices)
      ),
      t
    ), O(
      x(
        rt(r, e, o),
        P(([c, a]) => Re(a)),
        E(([c, a, p]) => Ct(a.groupOffsetTree, Math.max(c - p, 0), "v")[0]),
        Z(),
        E((c) => [c])
      ),
      i
    ), { groupCounts: s, topItemsIndexes: i };
  },
  X(Et, at)
), Pt = U(
  ([{ log: t }]) => {
    const e = C(!1), n = ht(
      x(
        e,
        P((o) => o),
        Z()
      )
    );
    return K(e, (o) => {
      o && st(t)("props updated", {}, mt.DEBUG);
    }), { didMount: n, propsReady: e };
  },
  X(Vt),
  { singleton: !0 }
), zo = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function Dn(t) {
  const e = typeof t == "number" ? { index: t } : t;
  return e.align || (e.align = "start"), (!e.behavior || !zo) && (e.behavior = "auto"), e.offset || (e.offset = 0), e;
}
const ce = U(
  ([
    { gap: t, listRefresh: e, sizes: n, totalCount: o },
    {
      fixedFooterHeight: r,
      fixedHeaderHeight: s,
      footerHeight: i,
      headerHeight: l,
      scrollingInProgress: c,
      scrollTo: a,
      smoothScrollTargetReached: p,
      viewportHeight: S
    },
    { log: g }
  ]) => {
    const h = $(), w = $(), v = C(0);
    let m = null, d = null, u = null;
    function T() {
      m && (m(), m = null), u && (u(), u = null), d && (clearTimeout(d), d = null), G(c, !1);
    }
    return O(
      x(
        h,
        _(n, S, o, v, l, i, g),
        _(t, s, r),
        E(
          ([
            [R, I, f, b, k, F, L, V],
            D,
            J,
            nt
          ]) => {
            const B = Dn(R), { align: Y, behavior: it, offset: dt } = B, St = b - 1, ft = _n(B, I, St);
            let ut = ie(ft, I.offsetTree, D) + F;
            Y === "end" ? (ut += J + Ct(I.sizeTree, ft)[1] - f + nt, ft === St && (ut += L)) : Y === "center" ? ut += (J + Ct(I.sizeTree, ft)[1] - f + nt) / 2 : ut -= k, dt && (ut += dt);
            const At = (xt) => {
              T(), xt ? (V("retrying to scroll to", { location: R }, mt.DEBUG), G(h, R)) : (G(w, !0), V("list did not change, scroll successful", {}, mt.DEBUG));
            };
            if (T(), it === "smooth") {
              let xt = !1;
              u = K(e, (Xt) => {
                xt = xt || Xt;
              }), m = bt(p, () => {
                At(xt);
              });
            } else
              m = bt(x(e, Vo(150)), At);
            return d = setTimeout(() => {
              T();
            }, 1200), G(c, !0), V("scrolling from index to", { behavior: it, index: ft, top: ut }, mt.DEBUG), { behavior: it, top: ut };
          }
        )
      ),
      a
    ), {
      scrollTargetReached: w,
      scrollToIndex: h,
      topListHeight: v
    };
  },
  X(Et, at, Vt),
  { singleton: !0 }
);
function Vo(t) {
  return (e) => {
    const n = setTimeout(() => {
      e(!1);
    }, t);
    return (o) => {
      o && (e(!0), clearTimeout(n));
    };
  };
}
function $e(t, e) {
  t == 0 ? e() : requestAnimationFrame(() => {
    $e(t - 1, e);
  });
}
function Ue(t, e) {
  const n = e - 1;
  return typeof t == "number" ? t : t.index === "LAST" ? n : t.index;
}
const ue = U(
  ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {
    const l = C(!0), c = C(0), a = C(!0);
    return O(
      x(
        i,
        _(c),
        P(([p, S]) => !!S),
        yt(!1)
      ),
      l
    ), O(
      x(
        i,
        _(c),
        P(([p, S]) => !!S),
        yt(!1)
      ),
      a
    ), K(
      x(
        rt(e, i),
        _(l, n, t, a),
        P(([[, p], S, { sizeTree: g }, h, w]) => p && (!j(g) || Me(h)) && !S && !w),
        _(c)
      ),
      ([, p]) => {
        bt(r, () => {
          G(a, !0);
        }), $e(4, () => {
          bt(o, () => {
            G(l, !0);
          }), G(s, p);
        });
      }
    ), {
      initialItemFinalLocationReached: a,
      initialTopMostItemIndex: c,
      scrolledToInitialItem: l
    };
  },
  X(Et, at, ce, Pt),
  { singleton: !0 }
);
function $n(t, e) {
  return Math.abs(t - e) < 1.01;
}
const le = "up", te = "down", Po = "none", Ao = {
  atBottom: !1,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
}, Mo = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {
  const i = C(!1), l = C(!0), c = $(), a = $(), p = C(4), S = C(Mo), g = ct(
    x(
      dn(x(A(r), jt(1), yt(!0)), x(A(r), jt(1), yt(!1), an(100))),
      Z()
    ),
    !1
  ), h = ct(
    x(dn(x(n, yt(!0)), x(n, yt(!1), an(200))), Z()),
    !1
  );
  O(
    x(
      rt(A(r), A(S)),
      E(([u, T]) => u <= T),
      Z()
    ),
    l
  ), O(x(l, Lt(50)), a);
  const w = ht(
    x(
      rt(o, A(s), A(e), A(t), A(p)),
      Rt((u, [{ scrollHeight: T, scrollTop: R }, I, f, b, k]) => {
        const F = R + I - T > -k, L = {
          scrollHeight: T,
          scrollTop: R,
          viewportHeight: I
        };
        if (F) {
          let D, J;
          return R > u.state.scrollTop ? (D = "SCROLLED_DOWN", J = u.state.scrollTop - R) : (D = "SIZE_DECREASED", J = u.state.scrollTop - R || u.scrollTopDelta), {
            atBottom: !0,
            atBottomBecause: D,
            scrollTopDelta: J,
            state: L
          };
        }
        let V;
        return L.scrollHeight > u.state.scrollHeight ? V = "SIZE_INCREASED" : I < u.state.viewportHeight ? V = "VIEWPORT_HEIGHT_DECREASING" : R < u.state.scrollTop ? V = "SCROLLING_UPWARDS" : V = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: !1,
          notAtBottomBecause: V,
          state: L
        };
      }, Ao),
      Z((u, T) => u && u.atBottom === T.atBottom)
    )
  ), v = ct(
    x(
      o,
      Rt(
        (u, { scrollHeight: T, scrollTop: R, viewportHeight: I }) => {
          if ($n(u.scrollHeight, T))
            return {
              changed: !1,
              jump: 0,
              scrollHeight: T,
              scrollTop: R
            };
          {
            const f = T - (R + I) < 1;
            return u.scrollTop !== R && f ? {
              changed: !0,
              jump: u.scrollTop - R,
              scrollHeight: T,
              scrollTop: R
            } : {
              changed: !0,
              jump: 0,
              scrollHeight: T,
              scrollTop: R
            };
          }
        },
        { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      P((u) => u.changed),
      E((u) => u.jump)
    ),
    0
  );
  O(
    x(
      w,
      E((u) => u.atBottom)
    ),
    i
  ), O(x(i, Lt(50)), c);
  const m = C(te);
  O(
    x(
      o,
      E(({ scrollTop: u }) => u),
      Z(),
      Rt(
        (u, T) => st(h) ? { direction: u.direction, prevScrollTop: T } : { direction: T < u.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E((u) => u.direction)
    ),
    m
  ), O(x(o, Lt(50), yt(Po)), m);
  const d = C(0);
  return O(
    x(
      g,
      P((u) => !u),
      yt(0)
    ),
    d
  ), O(
    x(
      r,
      Lt(100),
      _(g),
      P(([u, T]) => !!T),
      Rt(([u, T], [R]) => [T, R], [0, 0]),
      E(([u, T]) => T - u)
    ),
    d
  ), {
    atBottomState: w,
    atBottomStateChange: c,
    atBottomThreshold: p,
    atTopStateChange: a,
    atTopThreshold: S,
    isAtBottom: i,
    isAtTop: l,
    isScrolling: g,
    lastJumpDueToItemResize: v,
    scrollDirection: m,
    scrollVelocity: d
  };
}, X(at)), xe = "top", Te = "bottom", hn = "none";
function gn(t, e, n) {
  return typeof t == "number" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;
}
function In(t, e) {
  var n;
  return typeof t == "number" ? t : (n = t[e]) != null ? n : 0;
}
const Ke = U(
  ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {
    const s = $(), i = C(0), l = C(0), c = C(0), a = ct(
      x(
        rt(
          A(o),
          A(r),
          A(n),
          A(s, se),
          A(c),
          A(i),
          A(e),
          A(t),
          A(l)
        ),
        E(
          ([
            p,
            S,
            g,
            [h, w],
            v,
            m,
            d,
            u,
            T
          ]) => {
            const R = p - u, I = m + d, f = Math.max(g - R, 0);
            let b = hn;
            const k = In(T, xe), F = In(T, Te);
            return h -= u, h += g + d, w += g + d, w -= u, h > p + I - k && (b = le), w < p - f + S + F && (b = te), b !== hn ? [
              Math.max(R - g - gn(v, xe, b) - k, 0),
              R - f - d + S + gn(v, Te, b) + F
            ] : null;
          }
        ),
        P((p) => p != null),
        Z(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l,
      // input
      listBoundary: s,
      overscan: c,
      topListHeight: i,
      // output
      visibleRange: a
    };
  },
  X(at),
  { singleton: !0 }
);
function Wo(t, e, n) {
  if (Re(e)) {
    const o = Gn(t, e);
    return [
      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },
      { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }
    ];
  }
  return [{ data: n == null ? void 0 : n[0], index: t, offset: 0, size: 0 }];
}
const Be = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t, e, n, o, r, s) {
  const { lastIndex: i, lastOffset: l, lastSize: c } = r;
  let a = 0, p = 0;
  if (t.length > 0) {
    a = t[0].offset;
    const v = t[t.length - 1];
    p = v.offset + v.size;
  }
  const S = n - i, g = l + S * c + (S - 1) * o, h = a, w = g - p;
  return {
    bottom: p,
    firstItemIndex: s,
    items: Sn(t, r, s),
    offsetBottom: w,
    offsetTop: a,
    top: h,
    topItems: Sn(e, r, s),
    topListHeight: e.reduce((v, m) => m.size + v, 0),
    totalCount: n
  };
}
function Un(t, e, n, o, r, s) {
  let i = 0;
  if (n.groupIndices.length > 0)
    for (const p of n.groupIndices) {
      if (p - i >= t)
        break;
      i++;
    }
  const l = t + i, c = Ue(e, l), a = Array.from({ length: l }).map((p, S) => ({
    data: s[S + c],
    index: S + c,
    offset: 0,
    size: 0
  }));
  return Ie(a, [], l, r, n, o);
}
function Sn(t, e, n) {
  if (t.length === 0)
    return [];
  if (!Re(e))
    return t.map((a) => ({ ...a, index: a.index + n, originalIndex: a.index }));
  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ye(e.groupOffsetTree, o, r);
  let l, c = 0;
  for (const a of t) {
    (!l || l.end < a.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
    let p;
    a.index === l.start ? p = {
      index: c,
      type: "group"
    } : p = {
      groupIndex: c,
      index: a.index - (c + 1) + n
    }, s.push({
      ...p,
      data: a.data,
      offset: a.offset,
      originalIndex: a.index,
      size: a.size
    });
  }
  return s;
}
const Dt = U(
  ([
    { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },
    s,
    { listBoundary: i, topListHeight: l, visibleRange: c },
    { initialTopMostItemIndex: a, scrolledToInitialItem: p },
    { topListHeight: S },
    g,
    { didMount: h },
    { recalcInProgress: w }
  ]) => {
    const v = C([]), m = C(0), d = $();
    O(s.topItemsIndexes, v);
    const u = ct(
      x(
        rt(
          h,
          w,
          A(c, se),
          A(r),
          A(o),
          A(a),
          p,
          A(v),
          A(e),
          A(n),
          t
        ),
        P(([f, b, , k, , , , , , , F]) => {
          const L = F && F.length !== k;
          return f && !b && !L;
        }),
        E(
          ([
            ,
            ,
            [f, b],
            k,
            F,
            L,
            V,
            D,
            J,
            nt,
            B
          ]) => {
            const Y = F, { offsetTree: it, sizeTree: dt } = Y, St = st(m);
            if (k === 0)
              return { ...Be, totalCount: k };
            if (f === 0 && b === 0)
              return St === 0 ? { ...Be, totalCount: k } : Un(St, L, F, J, nt, B || []);
            if (j(dt))
              return St > 0 ? null : Ie(
                Wo(Ue(L, k), Y, B),
                [],
                k,
                nt,
                Y,
                J
              );
            const ft = [];
            if (D.length > 0) {
              const Mt = D[0], vt = D[D.length - 1];
              let Bt = 0;
              for (const y of ye(dt, Mt, vt)) {
                const N = y.value, Q = Math.max(y.start, Mt), lt = Math.min(y.end, vt);
                for (let tt = Q; tt <= lt; tt++)
                  ft.push({ data: B == null ? void 0 : B[tt], index: tt, offset: Bt, size: N }), Bt += N;
              }
            }
            if (!V)
              return Ie([], ft, k, nt, Y, J);
            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = Ho(it, f, b, ut);
            if (At.length === 0)
              return null;
            const xt = k - 1, Xt = ve([], (Mt) => {
              for (const vt of At) {
                const Bt = vt.value;
                let y = Bt.offset, N = vt.start;
                const Q = Bt.size;
                if (Bt.offset < f) {
                  N += Math.floor((f - Bt.offset + nt) / (Q + nt));
                  const tt = N - vt.start;
                  y += tt * Q + tt * nt;
                }
                N < ut && (y += (ut - N) * Q, N = ut);
                const lt = Math.min(vt.end, xt);
                for (let tt = N; tt <= lt && !(y >= b); tt++)
                  Mt.push({ data: B == null ? void 0 : B[tt], index: tt, offset: y, size: Q }), y += Q + nt;
              }
            });
            return Ie(Xt, ft, k, nt, Y, J);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        P((f) => f !== null),
        Z()
      ),
      Be
    );
    O(
      x(
        t,
        P(Me),
        E((f) => f == null ? void 0 : f.length)
      ),
      r
    ), O(
      x(
        u,
        E((f) => f.topListHeight)
      ),
      S
    ), O(S, l), O(
      x(
        u,
        E((f) => [f.top, f.bottom])
      ),
      i
    ), O(
      x(
        u,
        E((f) => f.items)
      ),
      d
    );
    const T = ht(
      x(
        u,
        P(({ items: f }) => f.length > 0),
        _(r, t),
        P(([{ items: f }, b]) => f[f.length - 1].originalIndex === b - 1),
        E(([, f, b]) => [f - 1, b]),
        Z(se),
        E(([f]) => f)
      )
    ), R = ht(
      x(
        u,
        Lt(200),
        P(({ items: f, topItems: b }) => f.length > 0 && f[0].originalIndex === b.length),
        E(({ items: f }) => f[0].index),
        Z()
      )
    ), I = ht(
      x(
        u,
        P(({ items: f }) => f.length > 0),
        E(({ items: f }) => {
          let b = 0, k = f.length - 1;
          for (; f[b].type === "group" && b < k; )
            b++;
          for (; f[k].type === "group" && k > b; )
            k--;
          return {
            endIndex: f[k].index,
            startIndex: f[b].index
          };
        }),
        Z(Mn)
      )
    );
    return { endReached: T, initialItemCount: m, itemsRendered: d, listState: u, rangeChanged: I, startReached: R, topItemsIndexes: v, ...g };
  },
  X(
    Et,
    Nn,
    Ke,
    ue,
    ce,
    ae,
    Pt,
    Ne
  ),
  { singleton: !0 }
), Kn = U(
  ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {
    const s = $(), i = ct(
      x(
        rt(n, t, o, e, r),
        E(([l, c, a, p, S]) => l + c + a + p + S.offsetBottom + S.bottom)
      ),
      0
    );
    return O(A(i), s), { totalListHeight: i, totalListHeightChanged: s };
  },
  X(at, Dt),
  { singleton: !0 }
), Go = U(
  ([{ viewportHeight: t }, { totalListHeight: e }]) => {
    const n = C(!1), o = ct(
      x(
        rt(n, t, e),
        P(([r]) => r),
        E(([, r, s]) => Math.max(0, r - s)),
        Lt(0),
        Z()
      ),
      0
    );
    return { alignToBottom: n, paddingTopAddition: o };
  },
  X(at, Kn),
  { singleton: !0 }
);
function xn(t) {
  return t ? t === "smooth" ? "smooth" : "auto" : !1;
}
const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
  ([
    { listRefresh: t, totalCount: e, fixedItemSize: n },
    { atBottomState: o, isAtBottom: r },
    { scrollToIndex: s },
    { scrolledToInitialItem: i },
    { didMount: l, propsReady: c },
    { log: a },
    { scrollingInProgress: p }
  ]) => {
    const S = C(!1), g = $();
    let h = null;
    function w(m) {
      G(s, {
        align: "end",
        behavior: m,
        index: "LAST"
      });
    }
    K(
      x(
        rt(x(A(e), jt(1)), l),
        _(A(S), r, i, p),
        E(([[m, d], u, T, R, I]) => {
          let f = d && R, b = "auto";
          return f && (b = _o(u, T || I), f = f && !!b), { followOutputBehavior: b, shouldFollow: f, totalCount: m };
        }),
        P(({ shouldFollow: m }) => m)
      ),
      ({ followOutputBehavior: m, totalCount: d }) => {
        h && (h(), h = null), st(n) ? requestAnimationFrame(() => {
          st(a)("following output to ", { totalCount: d }, mt.DEBUG), w(m);
        }) : h = bt(t, () => {
          st(a)("following output to ", { totalCount: d }, mt.DEBUG), w(m), h = null;
        });
      }
    );
    function v(m) {
      const d = bt(o, (u) => {
        m && !u.atBottom && u.notAtBottomBecause === "SIZE_INCREASED" && !h && (st(a)("scrolling to bottom due to increased size", {}, mt.DEBUG), w("auto"));
      });
      setTimeout(d, 100);
    }
    return K(
      x(
        rt(A(S), e, c),
        P(([m, , d]) => m && d),
        Rt(
          ({ value: m }, [, d]) => ({ refreshed: m === d, value: d }),
          { refreshed: !1, value: 0 }
        ),
        P(({ refreshed: m }) => m),
        _(S, e)
      ),
      ([, m]) => {
        st(i) && v(m !== !1);
      }
    ), K(g, () => {
      v(st(S) !== !1);
    }), K(rt(A(S), o), ([m, d]) => {
      m && !d.atBottom && d.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && w("auto");
    }), { autoscrollToBottom: g, followOutput: S };
  },
  X(Et, ae, ce, ue, Pt, Vt, at)
), Do = U(
  ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (O(
    x(
      l,
      _(s),
      P(([, c]) => c !== 0),
      _(r, o, e, n, t),
      E(([[, c], a, p, S, g, h = []]) => Un(c, a, p, S, g, h))
    ),
    i
  ), {}),
  X(Et, ue, Dt, Pt),
  { singleton: !0 }
), $o = U(
  ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {
    const o = C(0);
    return K(
      x(
        t,
        _(o),
        P(([, r]) => r !== 0),
        E(([, r]) => ({ top: r }))
      ),
      (r) => {
        bt(
          x(
            n,
            jt(1),
            P((s) => s.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              G(e, r);
            });
          }
        );
      }
    ), {
      initialScrollTop: o
    };
  },
  X(Pt, at, Dt),
  { singleton: !0 }
), Uo = ({
  itemBottom: t,
  itemTop: e,
  locationParams: { align: n, behavior: o, ...r },
  viewportBottom: s,
  viewportTop: i
}) => e < i ? { ...r, align: n != null ? n : "start", behavior: o } : t > s ? { ...r, align: n != null ? n : "end", behavior: o } : null, Ko = U(
  ([
    { gap: t, sizes: e, totalCount: n },
    { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },
    { scrollToIndex: a }
  ]) => {
    const p = $();
    return O(
      x(
        p,
        _(e, c, n, s, r, o, l),
        _(t),
        E(([[S, g, h, w, v, m, d, u], T]) => {
          const { align: R, behavior: I, calculateViewLocation: f = Uo, done: b, ...k } = S, F = _n(S, g, w - 1), L = ie(F, g.offsetTree, T) + v + m, V = L + Ct(g.sizeTree, F)[1], D = u + m, J = u + h - d, nt = f({
            itemBottom: V,
            itemTop: L,
            locationParams: { align: R, behavior: I, ...k },
            viewportBottom: J,
            viewportTop: D
          });
          return nt ? b && bt(
            x(
              i,
              P((B) => !B),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              jt(st(i) ? 1 : 2)
            ),
            b
          ) : b && b(), nt;
        }),
        P((S) => S !== null)
      ),
      a
    ), {
      scrollIntoView: p
    };
  },
  X(Et, at, ce, Dt, Vt),
  { singleton: !0 }
), jn = U(
  ([{ scrollVelocity: t }]) => {
    const e = C(!1), n = $(), o = C(!1);
    return O(
      x(
        t,
        _(o, e, n),
        P(([r, s]) => !!s),
        E(([r, s, i, l]) => {
          const { enter: c, exit: a } = s;
          if (i) {
            if (a(r, l))
              return !1;
          } else if (c(r, l))
            return !0;
          return i;
        }),
        Z()
      ),
      e
    ), K(
      x(rt(e, t, n), _(o)),
      ([[r, s, i], l]) => {
        r && l && l.change && l.change(s, i);
      }
    ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };
  },
  X(ae),
  { singleton: !0 }
), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {
  const n = $(), o = $(), r = $(), s = C(!1), i = C(void 0);
  return O(
    x(
      rt(n, o),
      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: a }, { offsetTop: p }]) => ({
        scrollHeight: l,
        scrollTop: Math.max(0, c - p),
        viewportHeight: a
      }))
    ),
    t
  ), O(
    x(
      e,
      _(o),
      E(([l, { offsetTop: c }]) => ({
        ...l,
        top: l.top + c
      }))
    ),
    r
  ), {
    customScrollParent: i,
    // config
    useWindowScroll: s,
    // input
    windowScrollContainerState: n,
    // signals
    windowScrollTo: r,
    windowViewportRect: o
  };
}, X(at)), jo = U(
  ([
    { sizeRanges: t, sizes: e },
    { headerHeight: n, scrollTop: o },
    { initialTopMostItemIndex: r },
    { didMount: s },
    { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }
  ]) => {
    const a = $(), p = C(void 0), S = C(null), g = C(null);
    return O(l, S), O(c, g), K(
      x(
        a,
        _(e, o, i, S, g, n)
      ),
      ([h, w, v, m, d, u, T]) => {
        const R = Bo(w.sizeTree);
        m && d !== null && u !== null && (v = d.scrollTop - u.offsetTop), v -= T, h({ ranges: R, scrollTop: v });
      }
    ), O(x(p, P(Me), E(qo)), r), O(
      x(
        s,
        _(p),
        P(([, h]) => h !== void 0),
        Z(),
        E(([, h]) => h.ranges)
      ),
      t
    ), {
      getState: a,
      restoreStateFrom: p
    };
  },
  X(Et, at, ue, Pt, je)
);
function qo(t) {
  return { align: "start", index: 0, offset: t.scrollTop };
}
const Yo = U(([{ topItemsIndexes: t }]) => {
  const e = C(0);
  return O(
    x(
      e,
      P((n) => n >= 0),
      E((n) => Array.from({ length: n }).map((o, r) => r))
    ),
    t
  ), { topItemCount: e };
}, X(Dt));
function qn(t) {
  let e = !1, n;
  return () => (e || (e = !0, n = t()), n);
}
const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Xo = U(
  ([
    { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },
    { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },
    { listState: c },
    { beforeUnshiftWith: a, gap: p, shiftWithOffset: S, sizes: g },
    { log: h },
    { recalcInProgress: w }
  ]) => {
    const v = ht(
      x(
        c,
        _(i),
        Rt(
          ([, d, u, T], [{ bottom: R, items: I, offsetBottom: f, totalCount: b }, k]) => {
            const F = R + f;
            let L = 0;
            return u === b && d.length > 0 && I.length > 0 && (I[0].originalIndex === 0 && d[0].originalIndex === 0 || (L = F - T, L !== 0 && (L += k))), [L, I, b, F];
          },
          [0, [], 0, 0]
        ),
        P(([d]) => d !== 0),
        _(o, l, n, r, h, w),
        P(([, d, u, T, , , R]) => !R && !T && d !== 0 && u === le),
        E(([[d], , , , , u]) => (u("Upward scrolling compensation", { amount: d }, mt.DEBUG), d))
      )
    );
    function m(d) {
      d > 0 ? (G(e, { behavior: "auto", top: -d }), G(t, 0)) : (G(t, 0), G(e, { behavior: "auto", top: -d }));
    }
    return K(x(v, _(t, s)), ([d, u, T]) => {
      T && Zo() ? G(t, u - d) : m(-d);
    }), K(
      x(
        rt(ct(s, !1), t, w),
        P(([d, u, T]) => !d && !T && u !== 0),
        E(([d, u]) => u),
        Lt(1)
      ),
      m
    ), O(
      x(
        S,
        E((d) => ({ top: -d }))
      ),
      e
    ), K(
      x(
        a,
        _(g, p),
        E(([d, { groupIndices: u, lastSize: T, sizeTree: R }, I]) => {
          function f(b) {
            return b * (T + I);
          }
          if (u.length === 0)
            return f(d);
          {
            let b = 0;
            const k = re(R, 0);
            let F = 0, L = 0;
            for (; F < d; ) {
              F++, b += k;
              let V = u.length === L + 1 ? 1 / 0 : u[L + 1] - u[L] - 1;
              F + V > d && (b -= k, V = d - F + 1), F += V, b += f(V), L++;
            }
            return b;
          }
        })
      ),
      (d) => {
        G(t, d), requestAnimationFrame(() => {
          G(e, { top: d }), requestAnimationFrame(() => {
            G(t, 0), G(w, !1);
          });
        });
      }
    ), { deviation: t };
  },
  X(at, ae, Dt, Et, Vt, Ne)
), Jo = U(
  ([
    t,
    e,
    n,
    o,
    r,
    s,
    i,
    l,
    c,
    a
  ]) => ({
    ...t,
    ...e,
    ...n,
    ...o,
    ...r,
    ...s,
    ...i,
    ...l,
    ...c,
    ...a
  }),
  X(
    Ke,
    Do,
    Pt,
    jn,
    Kn,
    $o,
    Go,
    je,
    Ko,
    Vt
  )
), Yn = U(
  ([
    {
      data: t,
      defaultItemSize: e,
      firstItemIndex: n,
      fixedItemSize: o,
      gap: r,
      groupIndices: s,
      itemSize: i,
      sizeRanges: l,
      sizes: c,
      statefulTotalCount: a,
      totalCount: p,
      trackItemSizes: S
    },
    { initialItemFinalLocationReached: g, initialTopMostItemIndex: h, scrolledToInitialItem: w },
    v,
    m,
    d,
    { listState: u, topItemsIndexes: T, ...R },
    { scrollToIndex: I },
    f,
    { topItemCount: b },
    { groupCounts: k },
    F
  ]) => (O(R.rangeChanged, F.scrollSeekRangeChanged), O(
    x(
      F.windowViewportRect,
      E((L) => L.visibleHeight)
    ),
    v.viewportHeight
  ), {
    data: t,
    defaultItemHeight: e,
    firstItemIndex: n,
    fixedItemHeight: o,
    gap: r,
    groupCounts: k,
    initialItemFinalLocationReached: g,
    initialTopMostItemIndex: h,
    scrolledToInitialItem: w,
    sizeRanges: l,
    topItemCount: b,
    topItemsIndexes: T,
    // input
    totalCount: p,
    ...d,
    groupIndices: s,
    itemSize: i,
    listState: u,
    scrollToIndex: I,
    // output
    statefulTotalCount: a,
    trackItemSizes: S,
    // exported from stateFlagsSystem
    ...R,
    // the bag of IO from featureGroup1System
    ...F,
    ...v,
    sizes: c,
    ...m
  }),
  X(
    Et,
    ue,
    at,
    jo,
    No,
    Dt,
    ce,
    Xo,
    Yo,
    Nn,
    Jo
  )
);
function Qo(t, e) {
  const n = {}, o = {};
  let r = 0;
  const s = t.length;
  for (; r < s; )
    o[t[r]] = 1, r += 1;
  for (const i in e)
    Object.hasOwn(o, i) || (n[i] = e[i]);
  return n;
}
const pe = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function qe(t, e, n) {
  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = H.createContext({});
  function c(d, u) {
    d.propsReady && G(d.propsReady, !1);
    for (const T of o) {
      const R = d[e.required[T]];
      G(R, u[T]);
    }
    for (const T of r)
      if (T in u) {
        const R = d[e.optional[T]];
        G(R, u[T]);
      }
    d.propsReady && G(d.propsReady, !0);
  }
  function a(d) {
    return s.reduce((u, T) => (u[T] = (R) => {
      const I = d[e.methods[T]];
      G(I, R);
    }, u), {});
  }
  function p(d) {
    return i.reduce((u, T) => (u[T] = ho(d[e.events[T]]), u), {});
  }
  const S = H.forwardRef((d, u) => {
    const { children: T, ...R } = d, [I] = H.useState(() => ve(Io(t), (k) => {
      c(k, R);
    })), [f] = H.useState(un(p, I));
    pe(() => {
      for (const k of i)
        k in R && K(f[k], R[k]);
      return () => {
        Object.values(f).map(We);
      };
    }, [R, f, I]), pe(() => {
      c(I, R);
    }), H.useImperativeHandle(u, cn(a(I)));
    const b = n;
    return /* @__PURE__ */ z(l.Provider, { value: I, children: n ? /* @__PURE__ */ z(b, { ...Qo([...o, ...r, ...i], R), children: T }) : T });
  }), g = (d) => {
    const u = H.useContext(l);
    return H.useCallback(
      (T) => {
        G(u[d], T);
      },
      [u, d]
    );
  }, h = (d) => {
    const T = H.useContext(l)[d], R = H.useCallback(
      (I) => K(T, I),
      [T]
    );
    return H.useSyncExternalStore(
      R,
      () => st(T),
      () => st(T)
    );
  }, w = (d) => {
    const T = H.useContext(l)[d], [R, I] = H.useState(un(st, T));
    return pe(
      () => K(T, (f) => {
        f !== R && I(cn(f));
      }),
      [T, R]
    ), R;
  }, v = H.version.startsWith("18") ? h : w;
  return {
    Component: S,
    useEmitter: (d, u) => {
      const R = H.useContext(l)[d];
      pe(() => K(R, u), [u, R]);
    },
    useEmitterValue: v,
    usePublisher: g
  };
}
const be = H.createContext(void 0), Zn = H.createContext(void 0), Xn = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function ke(t) {
  return "self" in t;
}
function tr(t) {
  return "body" in t;
}
function Jn(t, e, n, o = Yt, r, s) {
  const i = H.useRef(null), l = H.useRef(null), c = H.useRef(null), a = H.useCallback(
    (g) => {
      let h, w, v;
      const m = g.target;
      if (tr(m) || ke(m)) {
        const u = ke(m) ? m : m.defaultView;
        v = s ? u.scrollX : u.scrollY, h = s ? u.document.documentElement.scrollWidth : u.document.documentElement.scrollHeight, w = s ? u.innerWidth : u.innerHeight;
      } else
        v = s ? m.scrollLeft : m.scrollTop, h = s ? m.scrollWidth : m.scrollHeight, w = s ? m.offsetWidth : m.offsetHeight;
      const d = () => {
        t({
          scrollHeight: h,
          scrollTop: Math.max(v, 0),
          viewportHeight: w
        });
      };
      g.suppressFlushSync ? d() : co.flushSync(d), l.current !== null && (v === l.current || v <= 0 || v === h - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));
    },
    [t, e, s]
  );
  H.useEffect(() => {
    const g = r || i.current;
    return o(r || i.current), a({ suppressFlushSync: !0, target: g }), g.addEventListener("scroll", a, { passive: !0 }), () => {
      o(null), g.removeEventListener("scroll", a);
    };
  }, [i, a, n, o, r]);
  function p(g) {
    const h = i.current;
    if (!h || (s ? "offsetWidth" in h && h.offsetWidth === 0 : "offsetHeight" in h && h.offsetHeight === 0))
      return;
    const w = g.behavior === "smooth";
    let v, m, d;
    ke(h) ? (m = Math.max(
      wt(h.document.documentElement, s ? "width" : "height"),
      s ? h.document.documentElement.scrollWidth : h.document.documentElement.scrollHeight
    ), v = s ? h.innerWidth : h.innerHeight, d = s ? window.scrollX : window.scrollY) : (m = h[s ? "scrollWidth" : "scrollHeight"], v = wt(h, s ? "width" : "height"), d = h[s ? "scrollLeft" : "scrollTop"]);
    const u = m - v;
    if (g.top = Math.ceil(Math.max(Math.min(u, g.top), 0)), $n(v, m) || g.top === d) {
      t({ scrollHeight: m, scrollTop: d, viewportHeight: v }), w && e(!0);
      return;
    }
    w ? (l.current = g.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
      c.current = null, l.current = null, e(!0);
    }, 1e3)) : l.current = null, s && (g = { behavior: g.behavior, left: g.top }), h.scrollTo(g);
  }
  function S(g) {
    s && (g = { behavior: g.behavior, left: g.top }), i.current.scrollBy(g);
  }
  return { scrollByCallback: S, scrollerRef: i, scrollToCallback: p };
}
const Fe = "-webkit-sticky", Tn = "sticky", Ye = qn(() => {
  if (typeof document > "u")
    return Tn;
  const t = document.createElement("div");
  return t.style.position = Fe, t.style.position === Fe ? Fe : Tn;
});
function Ze(t) {
  return t;
}
const er = /* @__PURE__ */ U(() => {
  const t = C((c) => `Item ${c}`), e = C(null), n = C((c) => `Group ${c}`), o = C({}), r = C(Ze), s = C("div"), i = C(Yt), l = (c, a = null) => ct(
    x(
      o,
      E((p) => p[c]),
      Z()
    ),
    a
  );
  return {
    components: o,
    computeItemKey: r,
    context: e,
    EmptyPlaceholder: l("EmptyPlaceholder"),
    FooterComponent: l("Footer"),
    GroupComponent: l("Group", "div"),
    groupContent: n,
    HeaderComponent: l("Header"),
    HeaderFooterTag: s,
    ItemComponent: l("Item", "div"),
    itemContent: t,
    ListComponent: l("List", "div"),
    ScrollerComponent: l("Scroller", "div"),
    scrollerRef: i,
    ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
    TopItemListComponent: l("TopItemList")
  };
}), nr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(Yn, er)
), or = ({ height: t }) => /* @__PURE__ */ z("div", { style: { height: t } }), rr = { overflowAnchor: "none", position: Ye(), zIndex: 1 }, Qn = { overflowAnchor: "none" }, sr = { ...Qn, display: "inline-block", height: "100%" }, Cn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = M("listState"), o = gt("sizeRanges"), r = M("useWindowScroll"), s = M("customScrollParent"), i = gt("windowScrollContainerState"), l = gt("scrollContainerState"), c = s || r ? i : l, a = M("itemContent"), p = M("context"), S = M("groupContent"), g = M("trackItemSizes"), h = M("itemSize"), w = M("log"), v = gt("gap"), m = M("horizontalDirection"), { callbackRef: d } = On(
    o,
    h,
    g,
    e ? Yt : c,
    w,
    v,
    s,
    m,
    M("skipAnimationFrameInResizeObserver")
  ), [u, T] = H.useState(0);
  Qe("deviation", (B) => {
    u !== B && T(B);
  });
  const R = M("EmptyPlaceholder"), I = M("ScrollSeekPlaceholder") || or, f = M("ListComponent"), b = M("ItemComponent"), k = M("GroupComponent"), F = M("computeItemKey"), L = M("isSeeking"), V = M("groupIndices").length > 0, D = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt = e ? {} : {
    boxSizing: "border-box",
    ...m ? {
      display: "inline-block",
      height: "100%",
      marginLeft: u !== 0 ? u : D ? "auto" : 0,
      paddingLeft: n.offsetTop,
      paddingRight: n.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: u !== 0 ? u : D ? "auto" : 0,
      paddingBottom: n.offsetBottom,
      paddingTop: n.offsetTop
    },
    ...J ? {} : { visibility: "hidden" }
  };
  return !e && n.totalCount === 0 && R ? /* @__PURE__ */ z(R, { ...q(R, p) }) : /* @__PURE__ */ z(
    f,
    {
      ...q(f, p),
      "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: d,
      style: nt,
      children: (e ? n.topItems : n.items).map((B) => {
        const Y = B.originalIndex, it = F(Y + n.firstItemIndex, B.data, p);
        return L ? /* @__PURE__ */ _t(
          I,
          {
            ...q(I, p),
            height: B.size,
            index: B.index,
            key: it,
            type: B.type || "item",
            ...B.type === "group" ? {} : { groupIndex: B.groupIndex }
          }
        ) : B.type === "group" ? /* @__PURE__ */ _t(
          k,
          {
            ...q(k, p),
            "data-index": Y,
            "data-item-index": B.index,
            "data-known-size": B.size,
            key: it,
            style: rr
          },
          S(B.index, p)
        ) : /* @__PURE__ */ _t(
          b,
          {
            ...q(b, p),
            ...to(b, B.data),
            "data-index": Y,
            "data-item-group-index": B.groupIndex,
            "data-item-index": B.index,
            "data-known-size": B.size,
            key: it,
            style: m ? sr : Qn
          },
          V ? a(B.index, B.groupIndex, B.data, p) : a(B.index, B.data, p)
        );
      })
    }
  );
}), ir = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
}, lr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
}, Zt = (t) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t ? { display: "flex", flexDirection: "column" } : {}
}), cr = {
  position: Ye(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function q(t, e) {
  if (typeof t != "string")
    return { context: e };
}
function to(t, e) {
  return { item: typeof t == "string" ? void 0 : e };
}
const ur = /* @__PURE__ */ H.memo(function() {
  const e = M("HeaderComponent"), n = gt("headerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
}), ar = /* @__PURE__ */ H.memo(function() {
  const e = M("FooterComponent"), n = gt("footerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
});
function Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("scrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), S = e("scrollerRef"), g = e("context"), h = e("horizontalDirection") || !1, { scrollByCallback: w, scrollerRef: v, scrollToCallback: m } = Jn(
      c,
      p,
      a,
      S,
      void 0,
      h
    );
    return t("scrollTo", m), t("scrollBy", w), /* @__PURE__ */ z(
      a,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": !0,
        ref: v,
        style: { ...h ? lr : ir, ...i },
        tabIndex: 0,
        ...l,
        ...q(a, g),
        children: s
      }
    );
  });
}
function Je({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("windowScrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), S = e("totalListHeight"), g = e("deviation"), h = e("customScrollParent"), w = e("context"), v = H.useRef(null), m = e("scrollerRef"), { scrollByCallback: d, scrollerRef: u, scrollToCallback: T } = Jn(
      c,
      p,
      a,
      m,
      h
    );
    return Xn(() => {
      var R;
      return u.current = h || ((R = v.current) == null ? void 0 : R.ownerDocument.defaultView), () => {
        u.current = null;
      };
    }, [u, h]), t("windowScrollTo", T), t("scrollBy", d), /* @__PURE__ */ z(
      a,
      {
        ref: v,
        "data-virtuoso-scroller": !0,
        style: { position: "relative", ...i, ...S !== 0 ? { height: S + g } : {} },
        ...l,
        ...q(a, w),
        children: s
      }
    );
  });
}
const dr = ({ children: t }) => {
  const e = H.useContext(be), n = gt("viewportHeight"), o = gt("fixedItemHeight"), r = M("alignToBottom"), s = M("horizontalDirection"), i = H.useMemo(
    () => ne(n, (c) => wt(c, s ? "width" : "height")),
    [n, s]
  ), l = Ht(i, !0, M("skipAnimationFrameInResizeObserver"));
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: l, style: Zt(r), children: t });
}, fr = ({ children: t }) => {
  const e = H.useContext(be), n = gt("windowViewportRect"), o = gt("fixedItemHeight"), r = M("customScrollParent"), s = _e(
    n,
    r,
    M("skipAnimationFrameInResizeObserver")
  ), i = M("alignToBottom");
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(i), children: t });
}, mr = ({ children: t }) => {
  const e = M("TopItemListComponent") || "div", n = M("headerHeight"), o = { ...cr, marginTop: `${n}px` }, r = M("context");
  return /* @__PURE__ */ z(e, { style: o, ...q(e, r), children: t });
}, pr = /* @__PURE__ */ H.memo(function(e) {
  const n = M("useWindowScroll"), o = M("topItemsIndexes").length > 0, r = M("customScrollParent"), s = M("context"), i = r || n ? gr : hr, l = r || n ? fr : dr;
  return /* @__PURE__ */ Nt(i, { ...e, ...q(i, s), children: [
    o && /* @__PURE__ */ z(mr, { children: /* @__PURE__ */ z(Cn, { showTopList: !0 }) }),
    /* @__PURE__ */ Nt(l, { children: [
      /* @__PURE__ */ z(ur, {}),
      /* @__PURE__ */ z(Cn, {}),
      /* @__PURE__ */ z(ar, {})
    ] })
  ] });
}), {
  Component: eo,
  useEmitter: Qe,
  useEmitterValue: M,
  usePublisher: gt
} = /* @__PURE__ */ qe(
  nr,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "HeaderFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      horizontalDirection: "horizontalDirection",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  pr
), hr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: M, usePublisher: gt }), gr = /* @__PURE__ */ Je({ useEmitter: Qe, useEmitterValue: M, usePublisher: gt }), jr = eo, qr = eo, Ir = /* @__PURE__ */ U(() => {
  const t = C((a) => /* @__PURE__ */ Nt("td", { children: [
    "Item $",
    a
  ] })), e = C(null), n = C((a) => /* @__PURE__ */ Nt("td", { colSpan: 1e3, children: [
    "Group ",
    a
  ] })), o = C(null), r = C(null), s = C({}), i = C(Ze), l = C(Yt), c = (a, p = null) => ct(
    x(
      s,
      E((S) => S[a]),
      Z()
    ),
    p
  );
  return {
    components: s,
    computeItemKey: i,
    context: e,
    EmptyPlaceholder: c("EmptyPlaceholder"),
    FillerRow: c("FillerRow"),
    fixedFooterContent: r,
    fixedHeaderContent: o,
    itemContent: t,
    groupContent: n,
    ScrollerComponent: c("Scroller", "div"),
    scrollerRef: l,
    ScrollSeekPlaceholder: c("ScrollSeekPlaceholder"),
    TableBodyComponent: c("TableBody", "tbody"),
    TableComponent: c("Table", "table"),
    TableFooterComponent: c("TableFoot", "tfoot"),
    TableHeadComponent: c("TableHead", "thead"),
    TableRowComponent: c("TableRow", "tr"),
    GroupComponent: c("Group", "tr")
  };
}), Sr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(Yn, Ir)
), xr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { height: t } }) }), Tr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { border: 0, height: t, padding: 0 } }) }), Cr = { overflowAnchor: "none" }, wn = { position: Ye(), zIndex: 2, overflowAnchor: "none" }, vn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = W("listState"), o = W("computeItemKey"), r = W("firstItemIndex"), s = W("context"), i = W("isSeeking"), l = W("fixedHeaderHeight"), c = W("groupIndices").length > 0, a = W("itemContent"), p = W("groupContent"), S = W("ScrollSeekPlaceholder") || xr, g = W("GroupComponent"), h = W("TableRowComponent"), w = (e ? n.topItems : []).reduce((m, d, u) => (u === 0 ? m.push(d.size) : m.push(m[u - 1] + d.size), m), []), v = (e ? n.topItems : n.items).map((m) => {
    const d = m.originalIndex, u = o(d + r, m.data, s), T = e ? d === 0 ? 0 : w[d - 1] : 0;
    return i ? /* @__PURE__ */ _t(
      S,
      {
        ...q(S, s),
        height: m.size,
        index: m.index,
        key: u,
        type: m.type || "item"
      }
    ) : m.type === "group" ? /* @__PURE__ */ _t(
      g,
      {
        ...q(g, s),
        "data-index": d,
        "data-item-index": m.index,
        "data-known-size": m.size,
        key: u,
        style: {
          ...wn,
          top: l
        }
      },
      p(m.index, s)
    ) : /* @__PURE__ */ _t(
      h,
      {
        ...q(h, s),
        ...to(h, m.data),
        "data-index": d,
        "data-item-index": m.index,
        "data-known-size": m.size,
        "data-item-group-index": m.groupIndex,
        key: u,
        style: e ? { ...wn, top: l + T } : Cr
      },
      c ? a(m.index, m.groupIndex, m.data, s) : a(m.index, m.data, s)
    );
  });
  return /* @__PURE__ */ z(lo, { children: v });
}), wr = /* @__PURE__ */ H.memo(function() {
  const e = W("listState"), n = W("topItemsIndexes").length > 0, o = Tt("sizeRanges"), r = W("useWindowScroll"), s = W("customScrollParent"), i = Tt("windowScrollContainerState"), l = Tt("scrollContainerState"), c = s || r ? i : l, a = W("trackItemSizes"), p = W("itemSize"), S = W("log"), { callbackRef: g, ref: h } = On(
    o,
    p,
    a,
    c,
    S,
    void 0,
    s,
    !1,
    W("skipAnimationFrameInResizeObserver")
  ), [w, v] = H.useState(0);
  tn("deviation", (V) => {
    w !== V && (h.current.style.marginTop = `${V}px`, v(V));
  });
  const m = W("EmptyPlaceholder"), d = W("FillerRow") || Tr, u = W("TableBodyComponent"), T = W("paddingTopAddition"), R = W("statefulTotalCount"), I = W("context");
  if (R === 0 && m)
    return /* @__PURE__ */ z(m, { ...q(m, I) });
  const f = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), b = e.offsetTop + T + w - f, k = e.offsetBottom, F = b > 0 ? /* @__PURE__ */ z(d, { context: I, height: b }, "padding-top") : null, L = k > 0 ? /* @__PURE__ */ z(d, { context: I, height: k }, "padding-bottom") : null;
  return /* @__PURE__ */ Nt(u, { "data-testid": "virtuoso-item-list", ref: g, ...q(u, I), children: [
    F,
    n && /* @__PURE__ */ z(vn, { showTopList: !0 }),
    /* @__PURE__ */ z(vn, {}),
    L
  ] });
}), vr = ({ children: t }) => {
  const e = H.useContext(be), n = Tt("viewportHeight"), o = Tt("fixedItemHeight"), r = Ht(
    H.useMemo(() => ne(n, (s) => wt(s, "height")), [n]),
    !0,
    W("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: r, style: Zt(!1), children: t });
}, yr = ({ children: t }) => {
  const e = H.useContext(be), n = Tt("windowViewportRect"), o = Tt("fixedItemHeight"), r = W("customScrollParent"), s = _e(
    n,
    r,
    W("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(!1), children: t });
}, Rr = /* @__PURE__ */ H.memo(function(e) {
  const n = W("useWindowScroll"), o = W("customScrollParent"), r = Tt("fixedHeaderHeight"), s = Tt("fixedFooterHeight"), i = W("fixedHeaderContent"), l = W("fixedFooterContent"), c = W("context"), a = Ht(
    H.useMemo(() => ne(r, (u) => wt(u, "height")), [r]),
    !0,
    W("skipAnimationFrameInResizeObserver")
  ), p = Ht(
    H.useMemo(() => ne(s, (u) => wt(u, "height")), [s]),
    !0,
    W("skipAnimationFrameInResizeObserver")
  ), S = o || n ? Hr : br, g = o || n ? yr : vr, h = W("TableComponent"), w = W("TableHeadComponent"), v = W("TableFooterComponent"), m = i ? /* @__PURE__ */ z(
    w,
    {
      ref: a,
      style: { position: "sticky", top: 0, zIndex: 2 },
      ...q(w, c),
      children: i()
    },
    "TableHead"
  ) : null, d = l ? /* @__PURE__ */ z(
    v,
    {
      ref: p,
      style: { bottom: 0, position: "sticky", zIndex: 1 },
      ...q(v, c),
      children: l()
    },
    "TableFoot"
  ) : null;
  return /* @__PURE__ */ z(S, { ...e, ...q(S, c), children: /* @__PURE__ */ z(g, { children: /* @__PURE__ */ Nt(h, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...q(h, c), children: [
    m,
    /* @__PURE__ */ z(wr, {}, "TableBody"),
    d
  ] }) }) });
}), {
  Component: no,
  useEmitter: tn,
  useEmitterValue: W,
  usePublisher: Tt
} = /* @__PURE__ */ qe(
  Sr,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      firstItemIndex: "firstItemIndex",
      itemContent: "itemContent",
      groupContent: "groupContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedFooterContent: "fixedFooterContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      topItemCount: "topItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      groupCounts: "groupCounts",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  Rr
), br = /* @__PURE__ */ Xe({ useEmitter: tn, useEmitterValue: W, usePublisher: Tt }), Hr = /* @__PURE__ */ Je({ useEmitter: tn, useEmitterValue: W, usePublisher: Tt }), Yr = no, Zr = no, yn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, Er = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, { ceil: Rn, floor: Ce, max: ee, min: Oe, round: bn } = Math;
function Hn(t, e, n) {
  return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));
}
function Br(t) {
  return {
    ...Er,
    items: t
  };
}
function he(t, e) {
  return t && t.width === e.width && t.height === e.height;
}
function kr(t, e) {
  return t && t.column === e.column && t.row === e.row;
}
const Fr = /* @__PURE__ */ U(
  ([
    { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },
    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: a, smoothScrollTargetReached: p, viewportHeight: S },
    g,
    h,
    { didMount: w, propsReady: v },
    { customScrollParent: m, useWindowScroll: d, windowScrollContainerState: u, windowScrollTo: T, windowViewportRect: R },
    I
  ]) => {
    const f = C(0), b = C(0), k = C(yn), F = C({ height: 0, width: 0 }), L = C({ height: 0, width: 0 }), V = $(), D = $(), J = C(0), nt = C(null), B = C({ column: 0, row: 0 }), Y = $(), it = $(), dt = C(!1), St = C(0), ft = C(!0), ut = C(!1), At = C(!1);
    K(
      x(
        w,
        _(St),
        P(([y, N]) => !!N)
      ),
      () => {
        G(ft, !1);
      }
    ), K(
      x(
        rt(w, ft, L, F, St, ut),
        P(([y, N, Q, lt, , tt]) => y && !N && Q.height !== 0 && lt.height !== 0 && !tt)
      ),
      ([, , , , y]) => {
        G(ut, !0), $e(1, () => {
          G(V, y);
        }), bt(x(a), () => {
          G(e, [0, 0]), G(ft, !0);
        });
      }
    ), O(
      x(
        it,
        P((y) => y != null && y.scrollTop > 0),
        yt(0)
      ),
      b
    ), K(
      x(
        w,
        _(it),
        P(([, y]) => y != null)
      ),
      ([, y]) => {
        y && (G(F, y.viewport), G(L, y.item), G(B, y.gap), y.scrollTop > 0 && (G(dt, !0), bt(x(a, jt(1)), (N) => {
          G(dt, !1);
        }), G(c, { top: y.scrollTop })));
      }
    ), O(
      x(
        F,
        E(({ height: y }) => y)
      ),
      S
    ), O(
      x(
        rt(
          A(F, he),
          A(L, he),
          A(B, (y, N) => y && y.column === N.column && y.row === N.row),
          A(a)
        ),
        E(([y, N, Q, lt]) => ({
          gap: Q,
          item: N,
          scrollTop: lt,
          viewport: y
        }))
      ),
      Y
    ), O(
      x(
        rt(
          A(f),
          o,
          A(B, kr),
          A(L, he),
          A(F, he),
          A(nt),
          A(b),
          A(dt),
          A(ft),
          A(St)
        ),
        P(([, , , , , , , y]) => !y),
        E(
          ([
            y,
            [N, Q],
            lt,
            tt,
            kt,
            Jt,
            $t,
            ,
            de,
            Ft
          ]) => {
            const { column: Ot, row: Qt } = lt, { height: fe, width: He } = tt, { width: en } = kt;
            if ($t === 0 && (y === 0 || en === 0))
              return yn;
            if (He === 0) {
              const ln = Ue(Ft, y), io = ln + Math.max($t - 1, 0);
              return Br(Hn(ln, io, Jt));
            }
            const me = oo(en, He, Ot);
            let Ut, Wt;
            de ? N === 0 && Q === 0 && $t > 0 ? (Ut = 0, Wt = $t - 1) : (Ut = me * Ce((N + Qt) / (fe + Qt)), Wt = me * Rn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(y - 1, ee(Wt, me - 1)), Ut = Oe(Wt, ee(0, Ut))) : (Ut = 0, Wt = -1);
            const nn = Hn(Ut, Wt, Jt), { bottom: on, top: rn } = En(kt, lt, tt, nn), sn = Rn(y / me), so = sn * fe + (sn - 1) * Qt - on;
            return { bottom: on, itemHeight: fe, items: nn, itemWidth: He, offsetBottom: so, offsetTop: rn, top: rn };
          }
        )
      ),
      k
    ), O(
      x(
        nt,
        P((y) => y !== null),
        E((y) => y.length)
      ),
      f
    ), O(
      x(
        rt(F, L, k, B),
        P(([y, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && y.height !== 0),
        E(([y, N, { items: Q }, lt]) => {
          const { bottom: tt, top: kt } = En(y, lt, N, Q);
          return [kt, tt];
        }),
        Z(se)
      ),
      e
    );
    const xt = C(!1);
    O(
      x(
        a,
        _(xt),
        E(([y, N]) => N || y !== 0)
      ),
      xt
    );
    const Xt = ht(
      x(
        rt(k, f),
        P(([{ items: y }]) => y.length > 0),
        _(xt),
        P(([[y, N], Q]) => {
          const tt = y.items[y.items.length - 1].index === N - 1;
          return (Q || y.bottom > 0 && y.itemHeight > 0 && y.offsetBottom === 0 && y.items.length === N) && tt;
        }),
        E(([[, y]]) => y - 1),
        Z()
      )
    ), Mt = ht(
      x(
        A(k),
        P(({ items: y }) => y.length > 0 && y[0].index === 0),
        yt(0),
        Z()
      )
    ), vt = ht(
      x(
        A(k),
        _(dt),
        P(([{ items: y }, N]) => y.length > 0 && !N),
        E(([{ items: y }]) => ({
          endIndex: y[y.length - 1].index,
          startIndex: y[0].index
        })),
        Z(Mn),
        Lt(0)
      )
    );
    O(vt, h.scrollSeekRangeChanged), O(
      x(
        V,
        _(F, L, f, B),
        E(([y, N, Q, lt, tt]) => {
          const kt = Dn(y), { align: Jt, behavior: $t, offset: de } = kt;
          let Ft = kt.index;
          Ft === "LAST" && (Ft = lt - 1), Ft = ee(0, Ft, Oe(lt - 1, Ft));
          let Ot = Ae(N, tt, Q, Ft);
          return Jt === "end" ? Ot = bn(Ot - N.height + Q.height) : Jt === "center" && (Ot = bn(Ot - N.height / 2 + Q.height / 2)), de && (Ot += de), { behavior: $t, top: Ot };
        })
      ),
      c
    );
    const Bt = ct(
      x(
        k,
        E((y) => y.offsetBottom + y.bottom)
      ),
      0
    );
    return O(
      x(
        R,
        E((y) => ({ height: y.visibleHeight, width: y.visibleWidth }))
      ),
      F
    ), {
      customScrollParent: m,
      // input
      data: nt,
      deviation: J,
      footerHeight: r,
      gap: B,
      headerHeight: s,
      increaseViewportBy: t,
      initialItemCount: b,
      itemDimensions: L,
      overscan: n,
      restoreStateFrom: it,
      scrollBy: i,
      scrollContainerState: l,
      scrollHeight: D,
      scrollTo: c,
      scrollToIndex: V,
      scrollTop: a,
      smoothScrollTargetReached: p,
      totalCount: f,
      useWindowScroll: d,
      viewportDimensions: F,
      windowScrollContainerState: u,
      windowScrollTo: T,
      windowViewportRect: R,
      ...h,
      // output
      gridState: k,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: Bt,
      ...g,
      endReached: Xt,
      propsReady: v,
      rangeChanged: vt,
      startReached: Mt,
      stateChanged: Y,
      stateRestoreInProgress: dt,
      ...I
    };
  },
  X(Ke, at, ae, jn, Pt, je, Vt)
);
function oo(t, e, n) {
  return ee(1, Ce((t + n) / (Ce(e) + n)));
}
function En(t, e, n, o) {
  const { height: r } = n;
  if (r === void 0 || o.length === 0)
    return { bottom: 0, top: 0 };
  const s = Ae(t, e, n, o[0].index);
  return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };
}
function Ae(t, e, n, o) {
  const r = oo(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;
  return i > 0 ? i + e.row : i;
}
const Or = /* @__PURE__ */ U(() => {
  const t = C((S) => `Item ${S}`), e = C({}), n = C(null), o = C("virtuoso-grid-item"), r = C("virtuoso-grid-list"), s = C(Ze), i = C("div"), l = C(Yt), c = (S, g = null) => ct(
    x(
      e,
      E((h) => h[S]),
      Z()
    ),
    g
  ), a = C(!1), p = C(!1);
  return O(A(p), a), {
    components: e,
    computeItemKey: s,
    context: n,
    FooterComponent: c("Footer"),
    HeaderComponent: c("Header"),
    headerFooterTag: i,
    itemClassName: o,
    ItemComponent: c("Item", "div"),
    itemContent: t,
    listClassName: r,
    ListComponent: c("List", "div"),
    readyStateChanged: a,
    reportReadyState: p,
    ScrollerComponent: c("Scroller", "div"),
    scrollerRef: l,
    ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div")
  };
}), Lr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(Fr, Or)
), zr = /* @__PURE__ */ H.memo(function() {
  const e = et("gridState"), n = et("listClassName"), o = et("itemClassName"), r = et("itemContent"), s = et("computeItemKey"), i = et("isSeeking"), l = It("scrollHeight"), c = et("ItemComponent"), a = et("ListComponent"), p = et("ScrollSeekPlaceholder"), S = et("context"), g = It("itemDimensions"), h = It("gap"), w = et("log"), v = et("stateRestoreInProgress"), m = It("reportReadyState"), d = Ht(
    H.useMemo(
      () => (u) => {
        const T = u.parentElement.parentElement.scrollHeight;
        l(T);
        const R = u.firstChild;
        if (R) {
          const { height: I, width: f } = R.getBoundingClientRect();
          g({ height: I, width: f });
        }
        h({
          column: Bn("column-gap", getComputedStyle(u).columnGap, w),
          row: Bn("row-gap", getComputedStyle(u).rowGap, w)
        });
      },
      [l, g, h, w]
    ),
    !0,
    !1
  );
  return Xn(() => {
    e.itemHeight > 0 && e.itemWidth > 0 && m(!0);
  }, [e]), v ? null : /* @__PURE__ */ z(
    a,
    {
      className: n,
      ref: d,
      ...q(a, S),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },
      children: e.items.map((u) => {
        const T = s(u.index, u.data, S);
        return i ? /* @__PURE__ */ z(
          p,
          {
            ...q(p, S),
            height: e.itemHeight,
            index: u.index,
            width: e.itemWidth
          },
          T
        ) : /* @__PURE__ */ _t(
          c,
          {
            ...q(c, S),
            className: o,
            "data-index": u.index,
            key: T
          },
          r(u.index, u.data, S)
        );
      })
    }
  );
}), Vr = H.memo(function() {
  const e = et("HeaderComponent"), n = It("headerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
}), Pr = H.memo(function() {
  const e = et("FooterComponent"), n = It("footerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
}), Ar = ({ children: t }) => {
  const e = H.useContext(Zn), n = It("itemDimensions"), o = It("viewportDimensions"), r = Ht(
    H.useMemo(
      () => (s) => {
        o(s.getBoundingClientRect());
      },
      [o]
    ),
    !0,
    !1
  );
  return H.useEffect(() => {
    e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));
  }, [e, o, n]), /* @__PURE__ */ z("div", { ref: r, style: Zt(!1), children: t });
}, Mr = ({ children: t }) => {
  const e = H.useContext(Zn), n = It("windowViewportRect"), o = It("itemDimensions"), r = et("customScrollParent"), s = _e(n, r, !1);
  return H.useEffect(() => {
    e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { ref: s, style: Zt(!1), children: t });
}, Wr = /* @__PURE__ */ H.memo(function({ ...e }) {
  const n = et("useWindowScroll"), o = et("customScrollParent"), r = o || n ? Nr : _r, s = o || n ? Mr : Ar, i = et("context");
  return /* @__PURE__ */ z(r, { ...e, ...q(r, i), children: /* @__PURE__ */ Nt(s, { children: [
    /* @__PURE__ */ z(Vr, {}),
    /* @__PURE__ */ z(zr, {}),
    /* @__PURE__ */ z(Pr, {})
  ] }) });
}), {
  Component: Gr,
  useEmitter: ro,
  useEmitterValue: et,
  usePublisher: It
} = /* @__PURE__ */ qe(
  Lr,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      increaseViewportBy: "increaseViewportBy"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged",
      readyStateChanged: "readyStateChanged"
    }
  },
  Wr
), _r = /* @__PURE__ */ Xe({ useEmitter: ro, useEmitterValue: et, usePublisher: It }), Nr = /* @__PURE__ */ Je({ useEmitter: ro, useEmitterValue: et, usePublisher: It });
function Bn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
const Xr = Gr;
export {
  Zr as GroupedTableVirtuoso,
  qr as GroupedVirtuoso,
  mt as LogLevel,
  Yr as TableVirtuoso,
  jr as Virtuoso,
  Xr as VirtuosoGrid,
  Zn as VirtuosoGridMockContext,
  be as VirtuosoMockContext
};
